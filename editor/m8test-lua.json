{
  "Colors:getColorHex(kotlin.String, kotlin.Int, kotlin.Int)": {
    "description": "获取 image 中的坐标 (x,y) 的颜色16进制\n\n@param image 需要获取颜色的图片路径\n@param x 颜色x坐标\n@param y 颜色y坐标\n@return image 中的坐标 (x,y) 的颜色16进制，格式为 \"#RRGGBB\" 或 \"#AARRGGBB\"（如果包含透明度）",
    "prefix": "Colors:getColorHex(kotlin.String, kotlin.Int, kotlin.Int)",
    "body": "_colors:getColorHex(image, x, y)",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsgetColorHex(kotlin.String, kotlin.Int, kotlin.Int)"
  },
  "Colors:getColorHexInScreen(kotlin.Int, kotlin.Int)": {
    "description": "获取屏幕中的坐标 (x,y) 的颜色16进制, 会自动申请屏幕截图权限\n\n@param x 颜色x坐标\n@param y 颜色y坐标\n@return 屏幕中的坐标 (x,y) 的颜色16进制，格式为 \"#RRGGBB\" 或 \"#AARRGGBB\"（如果包含透明度）",
    "prefix": "Colors:getColorHexInScreen(kotlin.Int, kotlin.Int)",
    "body": "_colors:getColorHexInScreen(x, y)",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsgetColorHexInScreen(kotlin.Int, kotlin.Int)"
  },
  "Colors:isSimilar(kotlin.String, kotlin.String, kotlin.Int, kotlin.String, kotlin.Boolean)": {
    "description": "判断 color1 和 color2 是否相似。\n\n@param color1 需要比较的颜色1，支持格式：0x969696、#969696、969696（RGB），或 0xee969696（ARGB）。\n@param color2 需要比较的颜色2，支持格式：0x969696、#969696、969696（RGB），或 0xee969696（ARGB）。\n@param similarity 颜色相似度，范围 0, 100，0 表示最宽松（允许任何颜色），100 表示最严格（完全匹配）。\n@param algorithm 匹配算法，支持：equal，diff，rgb，rgb+，hs。\n@param ignoreAlpha 是否忽略透明度比较，默认为 true（包含透明度比较）。\n@return 如果两个颜色相似返回true，否则返回false",
    "prefix": "Colors:isSimilar(kotlin.String, kotlin.String, kotlin.Int, kotlin.String, kotlin.Boolean)",
    "body": "_colors:isSimilar(color1, color2, similarity, algorithm, ignoreAlpha)",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsisSimilar(kotlin.String, kotlin.String, kotlin.Int, kotlin.String, kotlin.Boolean)"
  },
  "Colors:getSimilarity(kotlin.String, kotlin.String, kotlin.String, kotlin.Boolean)": {
    "description": "判断 color1 和 color2 是否相似。\n\n@param color1 需要比较的颜色1，支持格式：0x969696、#969696、969696（RGB），或 0xee969696（ARGB）。\n@param color2 需要比较的颜色2，支持格式：0x969696、#969696、969696（RGB），或 0xee969696（ARGB）。\n@param algorithm 匹配算法，支持：equal，diff，rgb，rgb+，hs。\n@param ignoreAlpha 是否忽略透明度比较，默认为 true（包含透明度比较）。\n@return 颜色相似度，范围 0, 100，0 表示最宽松（允许任何颜色），100 表示最严格（完全匹配）。",
    "prefix": "Colors:getSimilarity(kotlin.String, kotlin.String, kotlin.String, kotlin.Boolean)",
    "body": "_colors:getSimilarity(color1, color2, algorithm, ignoreAlpha)",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsgetSimilarity(kotlin.String, kotlin.String, kotlin.String, kotlin.Boolean)"
  },
  "Colors:getGlobalName()": {
    "description": "",
    "prefix": "Colors:getGlobalName()",
    "body": "_colors:getGlobalName()",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsgetGlobalName()"
  },
  "Colors:getPublicType()": {
    "description": "",
    "prefix": "Colors:getPublicType()",
    "body": "_colors:getPublicType()",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsgetPublicType()"
  },
  "Colors:isPrefixRequired()": {
    "description": "",
    "prefix": "Colors:isPrefixRequired()",
    "body": "_colors:isPrefixRequired()",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsisPrefixRequired()"
  },
  "Colors:isSuffixRequired()": {
    "description": "",
    "prefix": "Colors:isSuffixRequired()",
    "body": "_colors:isSuffixRequired()",
    "scope": "lua",
    "prefixWithoutCallString": "ColorsisSuffixRequired()"
  },
  "M8TestCoordinateResult.M8TestCoordinateResult:getCoordinate()": {
    "description": "CoordinateResult:getCoordinate\n获取坐标\n\n@return 坐标",
    "prefix": ".M8TestCoordinateResult:getCoordinate()",
    "body": ":getCoordinate()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestCoordinateResultgetCoordinate()"
  },
  "M8TestCoordinateResult.M8TestCoordinateResult:getSimilarity()": {
    "description": "CoordinateResult:getSimilarity\n获取匹配结果的相似度\n\n@return 匹配结果的相似度",
    "prefix": ".M8TestCoordinateResult:getSimilarity()",
    "body": ":getSimilarity()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestCoordinateResultgetSimilarity()"
  },
  "Images:captureScreen(kotlin.String)": {
    "description": "将屏幕截图保存到 outputPath 中\n\n@param outputPath 保存路径, 如果该路径文件已存在，那么会删除后在保存到该文件",
    "prefix": "Images:captureScreen(kotlin.String)",
    "body": "_images:captureScreen(outputPath)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagescaptureScreen(kotlin.String)"
  },
  "Images:crop(kotlin.String, kotlin.String, kotlin.Function1)": {
    "description": "将 srcPath 裁剪一个矩形区域保存到 outputPath 中\n\n@param srcPath 原始图片路径\n@param outputPath 保存路径, 如果该路径文件已存在，那么会删除后在保存到该文件\n@param regionBuilder 构建矩形的函数Receiver(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d待构建的矩形对象, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE))",
    "prefix": "Images:crop(kotlin.String, kotlin.String, kotlin.Function1)",
    "body": "_images:crop(srcPath, outputPath, function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": "Imagescrop(kotlin.String, kotlin.String, kotlin.Function1)"
  },
  "Images:cropInScreen(kotlin.String, kotlin.Function1)": {
    "description": "将屏幕裁剪一个矩形区域保存到 outputPath 中, 会自动申请屏幕截图权限\n\n@param outputPath 保存路径, 如果该路径文件已存在，那么会删除后在保存到该文件\n@param regionBuilder 构建矩形的函数Receiver(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d待构建的矩形对象, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE))",
    "prefix": "Images:cropInScreen(kotlin.String, kotlin.Function1)",
    "body": "_images:cropInScreen(outputPath, function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagescropInScreen(kotlin.String, kotlin.Function1)"
  },
  "Images:matchTemplates(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.Int, kotlin.Boolean)": {
    "description": "从文件路径读取图像进行模板匹配（多目标）, 也就是从 srcPath 查找 templatePath。\n\n@param srcPath 原图像文件路径, 大图\n@param templatePath 模板图像文件路径, 小图\n@param similarity 匹配相似度，必须在 0, 100 范围内\n@param regionBuilder 限定仅在原图像的该区域内查找\n@param outputPath 匹配结果图像输出路径\n@param method 模板匹配方法\n@param parallel 是否启用并行处理\n@return 匹配到的所有结果（按相似度降序），包含匹配区域和相似度Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d如果 similarity 无效或文件路径无效, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "prefix": "Images:matchTemplates(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.Int, kotlin.Boolean)",
    "body": "_images:matchTemplates(srcPath, templatePath, similarity, limit, function(v1)\n    \nend, outputPath, method, parallel)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesmatchTemplates(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.Int, kotlin.Boolean)"
  },
  "Images:matchTemplatesInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.Int, kotlin.Boolean)": {
    "description": "从屏幕中查找 templatePath, 会自动申请屏幕截图权限\n\n@param templatePath 模板图像文件路径, 小图\n@param similarity 匹配相似度，必须在 0, 100 范围内\n@param regionBuilder 限定仅在原图像的该区域内查找\n@param outputPath 匹配结果图像输出路径\n@param method 模板匹配方法\n@param parallel 是否启用并行处理\n@return 匹配到的所有结果（按相似度降序），包含匹配区域和相似度Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d如果 similarity 无效或文件路径无效, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "prefix": "Images:matchTemplatesInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.Int, kotlin.Boolean)",
    "body": "_images:matchTemplatesInScreen(templatePath, similarity, limit, function(v1)\n    \nend, outputPath, method, parallel)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesmatchTemplatesInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.Int, kotlin.Boolean)"
  },
  "Images:compareColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Boolean)": {
    "description": "比较imagePath图片指定坐标的颜色是否与目标颜色匹配，或比较主坐标及其偏移点的颜色是否匹配。\n如果 colors 为 null 或空，则仅比较指定坐标 (x, y) 的颜色是否与 firstColor 匹配。 如果 colors 不为空，则解析颜色偏移字符串，比较主坐标及其偏移点的颜色是否匹配，使用每个偏移点的 similarity。\n\n@param imagePath 输入图像的文件路径。\n@param firstColor 目标颜色（或主颜色），支持格式：0x969696、#969696、969696（RGB），或 0xee969696（ARGB）。\n@param x 主坐标的横坐标。\n@param y 主坐标的纵坐标。\n@param similarity 颜色相似度（仅用于主颜色），范围 0, 100，0 表示最宽松（允许任何颜色），100 表示最严格（完全匹配）。\n@param regionBuilder 可选参数，指定查找区域（默认全图）。\n@param colors 颜色偏移字符串，格式如 \"6|1|0x969696|90,1|12|0xee969696|95,-4|0|#969696\"（可选）。\n@param algorithm 匹配算法，支持：equal，diff，rgb，rgb+，hs。\n@param ignoreAlpha 是否忽略透明度比较，默认为 true（包含透明度比较）。\n@return 是否所有坐标的颜色都匹配，true 表示匹配，false 表示不匹配。Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d如果 imagePath 无效、similarity 超出范围、algorithm 无效或颜色格式错误。, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "prefix": "Images:compareColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Boolean)",
    "body": "_images:compareColors(imagePath, firstColor, x, y, similarity, function(v1)\n    \nend, colors, algorithm, ignoreAlpha)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagescompareColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Boolean)"
  },
  "Images:compareColorsInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Boolean)": {
    "description": "比较屏幕中指定坐标的颜色是否与目标颜色匹配，或比较主坐标及其偏移点的颜色是否匹配, 会自动申请屏幕截图权限。\n如果 colors 为 null 或空，则仅比较指定坐标 (x, y) 的颜色是否与 firstColor 匹配。 如果 colors 不为空，则解析颜色偏移字符串，比较主坐标及其偏移点的颜色是否匹配，使用每个偏移点的 similarity。\n\n@param firstColor 目标颜色（或主颜色），支持格式：0x969696、#969696、969696（RGB），或 0xee969696（ARGB）。\n@param x 主坐标的横坐标。\n@param y 主坐标的纵坐标。\n@param similarity 颜色相似度（仅用于主颜色），范围 0, 100，0 表示最宽松（允许任何颜色），100 表示最严格（完全匹配）。\n@param regionBuilder 可选参数，指定查找区域（默认全图）。\n@param colors 颜色偏移字符串，格式如 \"6|1|0x969696|90,1|12|0xee969696|95,-4|0|#969696\"（可选）。\n@param algorithm 匹配算法，支持：equal，diff，rgb，rgb+，hs。\n@param ignoreAlpha 是否忽略透明度比较，默认为 true（包含透明度比较）。\n@return 是否所有坐标的颜色都匹配，true 表示匹配，false 表示不匹配。Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d如果 imagePath 无效、similarity 超出范围、algorithm 无效或颜色格式错误。, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "prefix": "Images:compareColorsInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Boolean)",
    "body": "_images:compareColorsInScreen(firstColor, x, y, similarity, function(v1)\n    \nend, colors, algorithm, ignoreAlpha)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagescompareColorsInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Boolean)"
  },
  "Images:findColorsInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Int, kotlin.Boolean)": {
    "description": "查找屏幕中中匹配的颜色点集合, 会自动申请屏幕截图权限\n如果 colors 为空，查找匹配主颜色的点；否则查找匹配主颜色及其偏移颜色的点，最多返回 limit 个。\n\n@param firstColor 目标主颜色，支持格式：0x969696、#969696、969696（RGB）或 0xee969696（ARGB）\n@param similarity 主颜色的相似度，范围 0, 100\n@param limit 最大返回的匹配点数量\n@param regionBuilder 查找区域构建函数\n@param colors 颜色偏移字符串，格式如 \"6|1|0x969696|90,1|12|0xee969696|95\"\n@param algorithm 匹配算法，支持：equal、diff、rgb、rgb+、hs\n@param direction 搜索方向\n@param ignoreAlpha 是否忽略透明度比较\n@return 匹配的坐标点及其相似度的集合Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d如果参数无效, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "prefix": "Images:findColorsInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Int, kotlin.Boolean)",
    "body": "_images:findColorsInScreen(firstColor, similarity, limit, function(v1)\n    \nend, colors, algorithm, direction, ignoreAlpha)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesfindColorsInScreen(kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Int, kotlin.Boolean)"
  },
  "Images:findColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Int, kotlin.Boolean)": {
    "description": "查找图像中匹配的颜色点集合\n如果 colors 为空，查找匹配主颜色的点；否则查找匹配主颜色及其偏移颜色的点，最多返回 limit 个。\n\n@param imagePath 输入图像文件路径\n@param firstColor 目标主颜色，支持格式：0x969696、#969696、969696（RGB）或 0xee969696（ARGB）\n@param similarity 主颜色的相似度，范围 0, 100\n@param limit 最大返回的匹配点数量\n@param regionBuilder 查找区域构建函数\n@param colors 颜色偏移字符串，格式如 \"6|1|0x969696|90,1|12|0xee969696|95\"\n@param algorithm 匹配算法，支持：equal、diff、rgb、rgb+、hs\n@param direction 搜索方向\n@param ignoreAlpha 是否忽略透明度比较\n@return 匹配的坐标点及其相似度的集合Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d如果参数无效, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "prefix": "Images:findColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Int, kotlin.Boolean)",
    "body": "_images:findColors(imagePath, firstColor, similarity, limit, function(v1)\n    \nend, colors, algorithm, direction, ignoreAlpha)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesfindColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1, kotlin.String, kotlin.String, kotlin.Int, kotlin.Boolean)"
  },
  "Images:getSize(kotlin.String)": {
    "description": "通过边界解码高效获取指定图片文件的宽高尺寸（不会加载完整图片像素数据）\n\u003cp\u003e使用 {@link android.util.Size} 封装图片的宽度和高度信息，适用于图片加载前的尺寸预判场景（如计算缩放比例）\u003c/p\u003e\n\n@param imagePath 待获取尺寸的图片文件路径（支持本地文件系统路径，如 SD 卡或内部存储路径）\n@return 封装图片宽度和高度的 {@link android.util.Size} 实例，宽高值为像素单位Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当图片路径为空或格式不合法时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当应用缺乏文件读取权限时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d极端情况下解码边界信息时内存不足（需配合内存优化策略使用）, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.OutOfMemoryError, exceptionAddress\u003djava.lang/OutOfMemoryError///PointingToDeclaration/)",
    "prefix": "Images:getSize(kotlin.String)",
    "body": "_images:getSize(imagePath)",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesgetSize(kotlin.String)"
  },
  "Images:getGlobalName()": {
    "description": "",
    "prefix": "Images:getGlobalName()",
    "body": "_images:getGlobalName()",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesgetGlobalName()"
  },
  "Images:getPublicType()": {
    "description": "",
    "prefix": "Images:getPublicType()",
    "body": "_images:getPublicType()",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesgetPublicType()"
  },
  "Images:isPrefixRequired()": {
    "description": "",
    "prefix": "Images:isPrefixRequired()",
    "body": "_images:isPrefixRequired()",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesisPrefixRequired()"
  },
  "Images:isSuffixRequired()": {
    "description": "",
    "prefix": "Images:isSuffixRequired()",
    "body": "_images:isSuffixRequired()",
    "scope": "lua",
    "prefixWithoutCallString": "ImagesisSuffixRequired()"
  },
  "M8TestRegionResult.M8TestRegionResult:getRegion()": {
    "description": "RegionResult:getRegion\n获取匹配结果的区域\n\n@return 匹配结果的区域",
    "prefix": ".M8TestRegionResult:getRegion()",
    "body": ":getRegion()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestRegionResultgetRegion()"
  },
  "M8TestRegionResult.M8TestRegionResult:getSimilarity()": {
    "description": "RegionResult:getSimilarity\n获取匹配结果的相似度\n\n@return 匹配结果的相似度",
    "prefix": ".M8TestRegionResult:getSimilarity()",
    "body": ":getSimilarity()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestRegionResultgetSimilarity()"
  },
  "M8TestResult.M8TestResult:getSimilarity()": {
    "description": "Result:getSimilarity\n获取匹配结果的相似度\n\n@return 匹配结果的相似度",
    "prefix": ".M8TestResult:getSimilarity()",
    "body": ":getSimilarity()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestResultgetSimilarity()"
  },
  "M8TestResults.M8TestResults:getAll()": {
    "description": "Results:getAll\n获取集合中的所有结果.\n\n@return 集合中的所有结果",
    "prefix": ".M8TestResults:getAll()",
    "body": ":getAll()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestResultsgetAll()"
  },
  "M8TestResults.M8TestResults:getBest()": {
    "description": "Results:getBest\n获取相似度最高的匹配结果\n\n@return 相似度最高的匹配结果",
    "prefix": ".M8TestResults:getBest()",
    "body": ":getBest()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestResultsgetBest()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getVariables(com.m8test.script.core.api.engine.ScriptContext)": {
    "description": "OpencvComponent:getVariables\n",
    "prefix": ".M8TestOpencvComponent:getVariables(com.m8test.script.core.api.engine.ScriptContext)",
    "body": ":getVariables(scriptContext)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetVariables(com.m8test.script.core.api.engine.ScriptContext)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:addClassLoader(dalvik.system.BaseDexClassLoader)": {
    "description": "OpencvComponent:addClassLoader\n",
    "prefix": ".M8TestOpencvComponent:addClassLoader(dalvik.system.BaseDexClassLoader)",
    "body": ":addClassLoader(classLoader)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentaddClassLoader(dalvik.system.BaseDexClassLoader)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:addClassLoader(kotlin.Function1)": {
    "description": "OpencvComponent:addClassLoader\n",
    "prefix": ".M8TestOpencvComponent:addClassLoader(kotlin.Function1)",
    "body": ":addClassLoader(function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentaddClassLoader(kotlin.Function1)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:addDependency(kotlin.Function1)": {
    "description": "OpencvComponent:addDependency\n",
    "prefix": ".M8TestOpencvComponent:addDependency(kotlin.Function1)",
    "body": ":addDependency(function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentaddDependency(kotlin.Function1)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:configureClassLoader(kotlin.Function1)": {
    "description": "OpencvComponent:configureClassLoader\n",
    "prefix": ".M8TestOpencvComponent:configureClassLoader(kotlin.Function1)",
    "body": ":configureClassLoader(function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentconfigureClassLoader(kotlin.Function1)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:configureClassLoader(dalvik.system.BaseDexClassLoader, kotlin.Function1)": {
    "description": "OpencvComponent:configureClassLoader\n",
    "prefix": ".M8TestOpencvComponent:configureClassLoader(dalvik.system.BaseDexClassLoader, kotlin.Function1)",
    "body": ":configureClassLoader(dexClassLoader, function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentconfigureClassLoader(dalvik.system.BaseDexClassLoader, kotlin.Function1)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:createClassLoader(kotlin.Function1)": {
    "description": "OpencvComponent:createClassLoader\n",
    "prefix": ".M8TestOpencvComponent:createClassLoader(kotlin.Function1)",
    "body": ":createClassLoader(function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentcreateClassLoader(kotlin.Function1)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getApplication()": {
    "description": "OpencvComponent:getApplication\n",
    "prefix": ".M8TestOpencvComponent:getApplication()",
    "body": ":getApplication()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetApplication()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getClassLoader()": {
    "description": "OpencvComponent:getClassLoader\n",
    "prefix": ".M8TestOpencvComponent:getClassLoader()",
    "body": ":getClassLoader()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetClassLoader()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getClassLoaders()": {
    "description": "OpencvComponent:getClassLoaders\n",
    "prefix": ".M8TestOpencvComponent:getClassLoaders()",
    "body": ":getClassLoaders()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetClassLoaders()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getFilesDir()": {
    "description": "OpencvComponent:getFilesDir\n",
    "prefix": ".M8TestOpencvComponent:getFilesDir()",
    "body": ":getFilesDir()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetFilesDir()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getName()": {
    "description": "OpencvComponent:getName\n",
    "prefix": ".M8TestOpencvComponent:getName()",
    "body": ":getName()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetName()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getPackageInfo()": {
    "description": "OpencvComponent:getPackageInfo\n",
    "prefix": ".M8TestOpencvComponent:getPackageInfo()",
    "body": ":getPackageInfo()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetPackageInfo()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getPluginInfo()": {
    "description": "OpencvComponent:getPluginInfo\n",
    "prefix": ".M8TestOpencvComponent:getPluginInfo()",
    "body": ":getPluginInfo()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetPluginInfo()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getResources()": {
    "description": "OpencvComponent:getResources\n",
    "prefix": ".M8TestOpencvComponent:getResources()",
    "body": ":getResources()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetResources()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:getSettings()": {
    "description": "OpencvComponent:getSettings\n",
    "prefix": ".M8TestOpencvComponent:getSettings()",
    "body": ":getSettings()",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentgetSettings()"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:loadClass(kotlin.String)": {
    "description": "OpencvComponent:loadClass\n",
    "prefix": ".M8TestOpencvComponent:loadClass(kotlin.String)",
    "body": ":loadClass(className)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentloadClass(kotlin.String)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:registerUICreator(com.m8test.script.core.api.ui.UICreator)": {
    "description": "OpencvComponent:registerUICreator\n",
    "prefix": ".M8TestOpencvComponent:registerUICreator(com.m8test.script.core.api.ui.UICreator)",
    "body": ":registerUICreator(uiCreator)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentregisterUICreator(com.m8test.script.core.api.ui.UICreator)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:removeClassLoader(dalvik.system.BaseDexClassLoader)": {
    "description": "OpencvComponent:removeClassLoader\n",
    "prefix": ".M8TestOpencvComponent:removeClassLoader(dalvik.system.BaseDexClassLoader)",
    "body": ":removeClassLoader(classLoader)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentremoveClassLoader(dalvik.system.BaseDexClassLoader)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:removeDependency(kotlin.Function1)": {
    "description": "OpencvComponent:removeDependency\n",
    "prefix": ".M8TestOpencvComponent:removeDependency(kotlin.Function1)",
    "body": ":removeDependency(function(v1)\n    \nend)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentremoveDependency(kotlin.Function1)"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent:unregisterUICreator(com.m8test.script.core.api.ui.UICreator)": {
    "description": "OpencvComponent:unregisterUICreator\n",
    "prefix": ".M8TestOpencvComponent:unregisterUICreator(com.m8test.script.core.api.ui.UICreator)",
    "body": ":unregisterUICreator(uiCreator)",
    "scope": "lua",
    "prefixWithoutCallString": ".M8TestOpencvComponentunregisterUICreator(com.m8test.script.core.api.ui.UICreator)"
  }
}