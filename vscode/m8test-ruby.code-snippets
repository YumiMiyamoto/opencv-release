{
  "Colors.getColorHex(kotlin.String, kotlin.Int, kotlin.Int)": {
    "prefix": "Colors.getColorHex(kotlin.String, kotlin.Int, kotlin.Int)",
    "body": "\\$colors.getColorHex(${1:image}, ${2:x}, ${3:y}$0)",
    "description": "获取图像中指定坐标的颜色十六进制值。\n从指定图像文件的(x,y)坐标提取像素颜色，并转换为标准化的十六进制字符串格式。 适用于需要精确获取图像中特定点颜色的场景。\n\n@param image 图像文件路径，支持常见格式（如PNG、JPEG等）\n@param x 目标像素的横坐标（像素单位，从左向右递增）\n@param y 目标像素的纵坐标（像素单位，从上向下递增）\n@return 颜色的十六进制字符串：     - 不包含透明度时：\"#RRGGBB\"（如\"#FF0080\"）     - 包含透明度时：\"#AARRGGBB\"（如\"#80FF0080\"）Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当图像路径无效、坐标超出图像范围时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当图像文件无法读取时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.io.IOException, exceptionAddress\u003djava.io/IOException///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Colors.getColorHexInDisplay(kotlin.Int, kotlin.Int, kotlin.Int)": {
    "prefix": "Colors.getColorHexInDisplay(kotlin.Int, kotlin.Int, kotlin.Int)",
    "body": "\\$colors.getColorHexInDisplay(${1:displayId}, ${2:x}, ${3:y}$0)",
    "description": "获取屏幕中指定坐标的颜色十六进制值（自动申请权限）。\n实时获取屏幕指定位置的像素颜色，自动处理屏幕截图权限申请，适用于界面元素颜色验证。\n\n@param displayId 屏幕标识符：     - 0 表示物理屏幕的镜像     - 其他值表示对应的虚拟屏幕\n@param x 目标像素的横坐标（基于屏幕分辨率，从左向右递增）\n@param y 目标像素的纵坐标（基于屏幕分辨率，从上向下递增）\n@return 颜色的十六进制字符串：     - 不包含透明度时：\"#RRGGBB\"     - 包含透明度时：\"#AARRGGBB\"Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当屏幕ID无效或坐标超出屏幕范围时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当屏幕截图权限申请失败时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Colors.isSimilar(kotlin.String, kotlin.String, kotlin.Int, kotlin.String, kotlin.Boolean)": {
    "prefix": "Colors.isSimilar(kotlin.String, kotlin.String, kotlin.Int, kotlin.String, kotlin.Boolean)",
    "body": "\\$colors.isSimilar(${1:color1}, ${2:color2}, ${3:similarity}, ${4:algorithm}, ${5:ignoreAlpha}$0)",
    "description": "判断两个颜色是否达到指定相似度。\n使用指定算法比较两种颜色的相似度，并判断是否满足设定的阈值要求。 支持多种颜色格式输入和比较策略，满足不同场景的精度需求。\n\n@param color1 待比较的第一个颜色，支持格式：     - RGB：0x969696、#969696、969696     - ARGB：0xee969696（包含透明度通道）\n@param color2 待比较的第二个颜色，支持格式同上\n@param similarity 相似度阈值（范围0-100）：     - 0表示最宽松（允许任何颜色）     - 100表示最严格（要求完全匹配）     null时使用默认阈值（通常为90）\n@param algorithm 比较算法，支持以下值：     - \"equal\": 完全相等匹配（仅当两个颜色完全相同时返回true）     - \"diff\": 基于颜色差值的比较     - \"rgb\": 分别比较RGB三个通道的差异     - \"rgb+\": 增强型RGB比较（考虑人眼对不同颜色的敏感度）     - \"hs\": 基于色相和饱和度的比较     null时使用默认算法（通常为\"rgb+\"）\n@param ignoreAlpha 是否忽略透明度通道：     - true: 仅比较RGB通道     - false: 同时比较ARGB四个通道     null时默认值为true\n@return true表示两个颜色的相似度达到或超过阈值，false则表示未达到Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当颜色格式无效、算法不支持或相似度超出范围时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Colors.getSimilarity(kotlin.String, kotlin.String, kotlin.String, kotlin.Boolean)": {
    "prefix": "Colors.getSimilarity(kotlin.String, kotlin.String, kotlin.String, kotlin.Boolean)",
    "body": "\\$colors.getSimilarity(${1:color1}, ${2:color2}, ${3:algorithm}, ${4:ignoreAlpha}$0)",
    "description": "计算两个颜色的相似度得分。\n使用指定算法量化两个颜色的相似程度，返回0-100的得分，值越高表示颜色越相似。 适用于需要知道具体相似程度而非简单判断是否匹配的场景。\n\n@param color1 待比较的第一个颜色，支持格式同isSimilar方法\n@param color2 待比较的第二个颜色，支持格式同isSimilar方法\n@param algorithm 比较算法，支持值同isSimilar方法，null使用默认算法\n@param ignoreAlpha 是否忽略透明度通道，规则同isSimilar方法，null默认true\n@return 相似度得分（0-100）：     - 100表示完全相同     - 0表示差异最大Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当颜色格式无效或算法不支持时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Colors.getGlobalName()": {
    "prefix": "Colors.getGlobalName()",
    "body": "\\$colors.getGlobalName($0)",
    "description": "",
    "scope": "ruby"
  },
  "Colors.getPublicType()": {
    "prefix": "Colors.getPublicType()",
    "body": "\\$colors.getPublicType($0)",
    "description": "",
    "scope": "ruby"
  },
  "Colors.isPrefixRequired()": {
    "prefix": "Colors.isPrefixRequired()",
    "body": "\\$colors.isPrefixRequired($0)",
    "description": "",
    "scope": "ruby"
  },
  "Colors.isSuffixRequired()": {
    "prefix": "Colors.isSuffixRequired()",
    "body": "\\$colors.isSuffixRequired($0)",
    "description": "",
    "scope": "ruby"
  },
  "M8TestCoordinateResult.M8TestCoordinateResult.getCoordinate()": {
    "prefix": ".M8TestCoordinateResult.getCoordinate()",
    "body": ".getCoordinate($0)",
    "description": "CoordinateResult.getCoordinate\n获取坐标\n\n@return 坐标",
    "scope": "ruby"
  },
  "M8TestCoordinateResult.M8TestCoordinateResult.getSimilarity()": {
    "prefix": ".M8TestCoordinateResult.getSimilarity()",
    "body": ".getSimilarity($0)",
    "description": "CoordinateResult.getSimilarity\n获取匹配结果的相似度\n\n@return 匹配结果的相似度",
    "scope": "ruby"
  },
  "Images.captureDisplay(kotlin.Int, kotlin.String)": {
    "prefix": "Images.captureDisplay(kotlin.Int, kotlin.String)",
    "body": "\\$images.captureDisplay(${1:displayId}, ${2:outputPath}$0)",
    "description": "捕获指定屏幕并保存为图像文件。\n该方法会截取指定屏幕的完整内容，并保存到指定路径。如果目标文件已存在， 会先删除原有文件再写入新内容。适用于获取当前屏幕状态作为操作依据或证据。\n\n@param displayId 屏幕标识符：     - 0 表示物理屏幕的镜像     - 其他值表示对应的虚拟屏幕\n@param outputPath 图像保存路径，需包含文件名及扩展名（如 \"/sdcard/screen.png\"）Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当应用缺乏屏幕截图权限或文件写入权限时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当输出路径无效或屏幕ID不存在时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.crop(kotlin.String, kotlin.String, kotlin.Function1)": {
    "prefix": "Images.crop(kotlin.String, kotlin.String, kotlin.Function1)",
    "body": "\\$images.crop(${1:srcPath}, ${2:outputPath}, ${5:lambda {|${3:v1}|-\u003e \n    $4\n\\}}$0)",
    "description": "裁剪图像文件的指定区域并保存。\n从指定的源图像中裁剪由regionBuilder定义的矩形区域，将结果保存到目标路径。 适用于提取图像中的特定部分进行后续分析。\n\n@param srcPath 源图像文件路径，必须是可读取的本地图像文件\n@param outputPath 裁剪结果保存路径，若文件已存在会被覆盖\n@param regionBuilder 用于定义裁剪区域的lambda表达式，通过操作Rect对象设置区域坐标Receiver(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d待构建的矩形对象，通过设置left、top、right、bottom属性定义裁剪区域, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE))Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当源文件不存在、路径无效或区域设置不合法时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当文件读写过程中发生错误时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dIOException, exceptionAddress\u003dnull)",
    "scope": "ruby"
  },
  "Images.cropInDisplay(kotlin.Int, kotlin.String, kotlin.Function1)": {
    "prefix": "Images.cropInDisplay(kotlin.Int, kotlin.String, kotlin.Function1)",
    "body": "\\$images.cropInDisplay(${1:displayId}, ${2:outputPath}, ${5:lambda {|${3:v1}|-\u003e \n    $4\n\\}}$0)",
    "description": "裁剪屏幕指定区域并保存为图像文件（自动申请权限）。\n结合屏幕截图与区域裁剪功能，直接从指定屏幕截取矩形区域并保存。适用于快速获取 屏幕特定区域的图像，如控件截图、验证码区域等。\n\n@param displayId 屏幕标识符：0表示物理屏幕镜像，其他值表示虚拟屏幕\n@param outputPath 裁剪结果保存路径，若文件已存在会被覆盖\n@param regionBuilder 用于定义裁剪区域的lambda表达式，坐标基于屏幕分辨率Receiver(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d待构建的矩形对象，通过设置left、top、right、bottom属性定义裁剪区域, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE))Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当自动申请权限失败时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当路径无效、屏幕ID不存在或区域设置不合法时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.matchTemplates(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)": {
    "prefix": "Images.matchTemplates(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)",
    "body": "\\$images.matchTemplates(${1:srcPath}, ${2:templatePath}, ${3:similarity}, ${4:limit}, ${7:lambda {|${5:v1}|-\u003e \n    $6\n\\}}$0)",
    "description": "在图像中查找匹配的模板（多目标支持）。\n从源图像中搜索与模板图像相似的所有区域，返回按相似度降序排列的匹配结果。 适用于在大图中定位小图元素，如在界面截图中查找按钮、图标等。\n\n@param srcPath 源图像文件路径（大图），作为搜索范围\n@param templatePath 模板图像文件路径（小图），作为搜索目标\n@param similarity 匹配相似度阈值（0-100），值越高匹配要求越严格；null使用默认值\n@param limit 最大返回结果数量，null表示无限制\n@param config 配置构建器，用于设置高级匹配参数\n@return 包含所有匹配区域的Results对象，每个结果包含区域坐标和相似度Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当相似度超出范围、文件路径无效或图像无法解析时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)See(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d了解更多配置选项, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dcom.m8test.image.api.config.MatchTemplatesConfig, address\u003dcom.m8test.image.api.config/MatchTemplatesConfig///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.matchTemplatesInDisplay(kotlin.Int, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)": {
    "prefix": "Images.matchTemplatesInDisplay(kotlin.Int, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)",
    "body": "\\$images.matchTemplatesInDisplay(${1:displayId}, ${2:templatePath}, ${3:similarity}, ${4:limit}, ${7:lambda {|${5:v1}|-\u003e \n    $6\n\\}}$0)",
    "description": "在屏幕中查找匹配的模板（自动申请权限）。\n结合屏幕截图与模板匹配功能，直接在指定屏幕中搜索与模板相似的区域。 适用于界面元素定位、自动化操作等场景。\n\n@param displayId 屏幕标识符：0表示物理屏幕镜像，其他值表示虚拟屏幕\n@param templatePath 模板图像文件路径（小图），作为搜索目标\n@param similarity 匹配相似度阈值（0-100），值越高匹配要求越严格；null使用默认值\n@param limit 最大返回结果数量，null表示无限制\n@param config 配置构建器，用于设置高级匹配参数\n@return 包含所有匹配区域的Results对象，每个结果包含区域坐标和相似度Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当相似度超出范围、文件路径无效或屏幕ID不存在时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当自动申请权限失败时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)See(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d了解更多配置选项, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dcom.m8test.image.api.config.MatchTemplatesConfig, address\u003dcom.m8test.image.api.config/MatchTemplatesConfig///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.compareColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1)": {
    "prefix": "Images.compareColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1)",
    "body": "\\$images.compareColors(${1:imagePath}, ${2:firstColor}, ${3:x}, ${4:y}, ${5:similarity}, ${8:lambda {|${6:v1}|-\u003e \n    $7\n\\}}$0)",
    "description": "比较图像中指定坐标的颜色是否匹配目标颜色。\n支持两种匹配模式：\nOl(children\u003d[Li(children\u003d[P(children\u003d[Text(body\u003d当配置中colors为空时，仅比较(x,y)坐标颜色与firstColor的相似度, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}), Li(children\u003d[P(children\u003d[Text(body\u003d当配置中colors不为空时，同时比较主坐标及偏移点的颜色是否匹配, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{})], params\u003d{start\u003d1})\n适用于验证像素级颜色信息，如状态指示、颜色标识等场景。\n\n@param imagePath 待分析的图像文件路径\n@param firstColor 目标主颜色，支持格式：     - RGB: 0x969696、#969696、969696     - ARGB: 0xee969696（包含透明度）\n@param x 主坐标的横坐标（像素单位）\n@param y 主坐标的纵坐标（像素单位）\n@param similarity 主颜色相似度阈值（0-100），null使用默认值\n@param config 颜色比较配置构建器\n@return true表示所有指定坐标的颜色均匹配，false表示存在不匹配Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当参数无效、颜色格式错误或算法不支持时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)See(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d了解更多配置选项, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dcom.m8test.image.api.config.CompareColorsConfig, address\u003dcom.m8test.image.api.config/CompareColorsConfig///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.compareColorsInDisplay(kotlin.Int, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1)": {
    "prefix": "Images.compareColorsInDisplay(kotlin.Int, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Function1)",
    "body": "\\$images.compareColorsInDisplay(${1:displayId}, ${2:firstColor}, ${3:x}, ${4:y}, ${5:similarity}, ${8:lambda {|${6:v1}|-\u003e \n    $7\n\\}}$0)",
    "description": "比较屏幕中指定坐标的颜色是否匹配目标颜色（自动申请权限）。\n直接从屏幕获取指定坐标的颜色信息进行比较，支持主坐标及偏移点的多颜色验证， 适用于实时验证屏幕元素的颜色状态。\n\n@param displayId 屏幕标识符：0表示物理屏幕镜像，其他值表示虚拟屏幕\n@param firstColor 目标主颜色，支持RGB和ARGB格式（同compareColors方法）\n@param x 主坐标的横坐标（基于屏幕分辨率）\n@param y 主坐标的纵坐标（基于屏幕分辨率）\n@param similarity 主颜色相似度阈值（0-100），null使用默认值\n@param config 颜色比较配置构建器\n@return true表示所有指定坐标的颜色均匹配，false表示存在不匹配Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当参数无效、颜色格式错误或算法不支持时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当自动申请权限失败时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)See(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d了解更多配置选项, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dcom.m8test.image.api.config.CompareColorsConfig, address\u003dcom.m8test.image.api.config/CompareColorsConfig///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.findColorsInDisplay(kotlin.Int, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)": {
    "prefix": "Images.findColorsInDisplay(kotlin.Int, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)",
    "body": "\\$images.findColorsInDisplay(${1:displayId}, ${2:firstColor}, ${3:similarity}, ${4:limit}, ${7:lambda {|${5:v1}|-\u003e \n    $6\n\\}}$0)",
    "description": "在屏幕中查找匹配指定颜色的所有点（自动申请权限）。\n扫描指定屏幕，返回所有与目标颜色相似的坐标点，按相似度降序排列。 适用于查找特定颜色的元素分布，如地图标记、数据可视化点等。\n\n@param displayId 屏幕标识符：0表示物理屏幕镜像，其他值表示虚拟屏幕\n@param firstColor 目标主颜色，支持RGB和ARGB格式\n@param similarity 颜色相似度阈值（0-100），null使用默认值\n@param limit 最大返回结果数量，null表示无限制\n@param config 颜色查找配置构建器\n@return 包含匹配坐标的Results对象，每个结果包含坐标和相似度Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当参数无效或颜色格式错误时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当自动申请权限失败时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)See(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d了解更多配置选项, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dcom.m8test.image.api.config.FindColorsConfig, address\u003dcom.m8test.image.api.config/FindColorsConfig///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.findColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)": {
    "prefix": "Images.findColors(kotlin.String, kotlin.String, kotlin.Int, kotlin.Int, kotlin.Function1)",
    "body": "\\$images.findColors(${1:imagePath}, ${2:firstColor}, ${3:similarity}, ${4:limit}, ${7:lambda {|${5:v1}|-\u003e \n    $6\n\\}}$0)",
    "description": "在图像中查找匹配指定颜色的所有点。\n扫描指定图像文件，返回所有与目标颜色相似的坐标点，按相似度降序排列。 适用于图像分析、颜色分布统计等场景。\n\n@param imagePath 待分析的图像文件路径\n@param firstColor 目标主颜色，支持RGB和ARGB格式\n@param similarity 颜色相似度阈值（0-100），null使用默认值\n@param limit 最大返回结果数量，null表示无限制\n@param config 颜色查找配置构建器\n@return 包含匹配坐标的Results对象，每个结果包含坐标和相似度Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当参数无效、颜色格式错误或文件无法读取时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)See(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d了解更多配置选项, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dcom.m8test.image.api.config.FindColorsConfig, address\u003dcom.m8test.image.api.config/FindColorsConfig///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.getSize(kotlin.String)": {
    "prefix": "Images.getSize(kotlin.String)",
    "body": "\\$images.getSize(${1:imagePath}$0)",
    "description": "高效获取图像文件的尺寸信息（不加载完整像素数据）。\n通过解析图像文件头部信息获取宽高，避免加载整个图像到内存，适用于预处理阶段的 尺寸判断、比例计算等场景，尤其对大尺寸图像性能优势明显。\n\n@param imagePath 待获取尺寸的图像文件路径（支持JPEG、PNG等常见格式）\n@return Size对象，包含图像的宽度（width）和高度（height），单位为像素Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当路径为空、文件不存在或格式不支持时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003dkotlin.IllegalArgumentException, exceptionAddress\u003dkotlin/IllegalArgumentException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d当应用缺乏文件读取权限时抛出, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.SecurityException, exceptionAddress\u003djava.lang/SecurityException///PointingToDeclaration/)Throws(root\u003dCustomDocTag(children\u003d[P(children\u003d[Text(body\u003d极端情况下解析元数据时发生内存不足, children\u003d[], params\u003d{})], params\u003d{})], params\u003d{}, name\u003dMARKDOWN_FILE), name\u003djava.lang.OutOfMemoryError, exceptionAddress\u003djava.lang/OutOfMemoryError///PointingToDeclaration/)",
    "scope": "ruby"
  },
  "Images.getGlobalName()": {
    "prefix": "Images.getGlobalName()",
    "body": "\\$images.getGlobalName($0)",
    "description": "",
    "scope": "ruby"
  },
  "Images.getPublicType()": {
    "prefix": "Images.getPublicType()",
    "body": "\\$images.getPublicType($0)",
    "description": "",
    "scope": "ruby"
  },
  "Images.isPrefixRequired()": {
    "prefix": "Images.isPrefixRequired()",
    "body": "\\$images.isPrefixRequired($0)",
    "description": "",
    "scope": "ruby"
  },
  "Images.isSuffixRequired()": {
    "prefix": "Images.isSuffixRequired()",
    "body": "\\$images.isSuffixRequired($0)",
    "description": "",
    "scope": "ruby"
  },
  "M8TestRegionResult.M8TestRegionResult.getRegion()": {
    "prefix": ".M8TestRegionResult.getRegion()",
    "body": ".getRegion($0)",
    "description": "RegionResult.getRegion\n获取匹配结果的区域\n\n@return 匹配结果的区域",
    "scope": "ruby"
  },
  "M8TestRegionResult.M8TestRegionResult.getSimilarity()": {
    "prefix": ".M8TestRegionResult.getSimilarity()",
    "body": ".getSimilarity($0)",
    "description": "RegionResult.getSimilarity\n获取匹配结果的相似度\n\n@return 匹配结果的相似度",
    "scope": "ruby"
  },
  "M8TestResult.M8TestResult.getSimilarity()": {
    "prefix": ".M8TestResult.getSimilarity()",
    "body": ".getSimilarity($0)",
    "description": "Result.getSimilarity\n获取匹配结果的相似度\n\n@return 匹配结果的相似度",
    "scope": "ruby"
  },
  "M8TestResults.M8TestResults.getAll()": {
    "prefix": ".M8TestResults.getAll()",
    "body": ".getAll($0)",
    "description": "Results.getAll\n获取集合中的所有结果.\n\n@return 集合中的所有结果",
    "scope": "ruby"
  },
  "M8TestResults.M8TestResults.getBest()": {
    "prefix": ".M8TestResults.getBest()",
    "body": ".getBest($0)",
    "description": "Results.getBest\n获取相似度最高的匹配结果\n\n@return 相似度最高的匹配结果",
    "scope": "ruby"
  },
  "M8TestCompareColorsConfig.M8TestCompareColorsConfig.setRegion(kotlin.Function1)": {
    "prefix": ".M8TestCompareColorsConfig.setRegion(kotlin.Function1)",
    "body": ".setRegion(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "CompareColorsConfig.setRegion\n设置区域构建器\n\n@param region 用于构建比较区域的lambda表达式，通过Rect的扩展函数定义比较区域；     null表示在整个图像范围内进行比较",
    "scope": "ruby"
  },
  "M8TestCompareColorsConfig.M8TestCompareColorsConfig.setColors(kotlin.String)": {
    "prefix": ".M8TestCompareColorsConfig.setColors(kotlin.String)",
    "body": ".setColors(${1:colors}$0)",
    "description": "CompareColorsConfig.setColors\n设置颜色偏移字符串\n\n@param colors 颜色偏移字符串，格式示例：\"6|1|0x969696|90,1|12|0xee969696|95,-4|0|#969696\"；     格式说明：每个偏移点由\"x偏移|y偏移|颜色值|相似度\"组成，多个点用逗号分隔；     null或空表示仅比较主坐标颜色",
    "scope": "ruby"
  },
  "M8TestCompareColorsConfig.M8TestCompareColorsConfig.setAlgorithm(kotlin.String)": {
    "prefix": ".M8TestCompareColorsConfig.setAlgorithm(kotlin.String)",
    "body": ".setAlgorithm(${1:algorithm}$0)",
    "description": "CompareColorsConfig.setAlgorithm\n设置颜色匹配算法\n\n@param algorithm 匹配算法标识，支持以下值：     - \"equal\": 完全相等匹配     - \"diff\": 差值比较     - \"rgb\": RGB通道分别比较     - \"rgb+\": 增强型RGB比较     - \"hs\": 色相饱和度比较     null表示使用默认算法",
    "scope": "ruby"
  },
  "M8TestCompareColorsConfig.M8TestCompareColorsConfig.setIgnoreAlpha(kotlin.Boolean)": {
    "prefix": ".M8TestCompareColorsConfig.setIgnoreAlpha(kotlin.Boolean)",
    "body": ".setIgnoreAlpha(${1:ignoreAlpha}$0)",
    "description": "CompareColorsConfig.setIgnoreAlpha\n设置是否忽略透明度比较的标志\n\n@param ignoreAlpha true表示忽略透明度进行比较，false表示包含透明度比较；     null表示使用默认设置（默认值为true）",
    "scope": "ruby"
  },
  "M8TestFindColorsConfig.M8TestFindColorsConfig.setRegion(kotlin.Function1)": {
    "prefix": ".M8TestFindColorsConfig.setRegion(kotlin.Function1)",
    "body": ".setRegion(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "FindColorsConfig.setRegion\n设置查找区域构建函数\n该函数用于定义颜色查找的区域范围\n\n@param builder 区域构建函数，为null时查找整个图像",
    "scope": "ruby"
  },
  "M8TestFindColorsConfig.M8TestFindColorsConfig.setColors(kotlin.String)": {
    "prefix": ".M8TestFindColorsConfig.setColors(kotlin.String)",
    "body": ".setColors(${1:colors}$0)",
    "description": "FindColorsConfig.setColors\n设置颜色偏移字符串\n格式如 \"6|1|0x969696|90,1|12|0xee969696|95\"，用于定义除主颜色外的其他匹配颜色\n\n@param colors 颜色偏移字符串，为null表示不使用偏移颜色",
    "scope": "ruby"
  },
  "M8TestFindColorsConfig.M8TestFindColorsConfig.setAlgorithm(kotlin.String)": {
    "prefix": ".M8TestFindColorsConfig.setAlgorithm(kotlin.String)",
    "body": ".setAlgorithm(${1:algorithm}$0)",
    "description": "FindColorsConfig.setAlgorithm\n设置匹配算法\n支持的算法包括：equal、diff、rgb、rgb+、hs\n\n@param algorithm 匹配算法名称，为null时使用默认算法",
    "scope": "ruby"
  },
  "M8TestFindColorsConfig.M8TestFindColorsConfig.setDirection(kotlin.Int)": {
    "prefix": ".M8TestFindColorsConfig.setDirection(kotlin.Int)",
    "body": ".setDirection(${1:direction}$0)",
    "description": "FindColorsConfig.setDirection\n设置搜索方向\n定义图像中颜色查找的扫描方向\n\n@param direction 搜索方向标识，为null时使用默认方向",
    "scope": "ruby"
  },
  "M8TestFindColorsConfig.M8TestFindColorsConfig.setIgnoreAlpha(kotlin.Boolean)": {
    "prefix": ".M8TestFindColorsConfig.setIgnoreAlpha(kotlin.Boolean)",
    "body": ".setIgnoreAlpha(${1:ignore}$0)",
    "description": "FindColorsConfig.setIgnoreAlpha\n设置是否忽略透明度比较\n\n@param ignore true表示忽略透明度，false表示考虑透明度，为null时使用默认设置",
    "scope": "ruby"
  },
  "M8TestMatchTemplatesConfig.M8TestMatchTemplatesConfig.setRegion(kotlin.Function1)": {
    "prefix": ".M8TestMatchTemplatesConfig.setRegion(kotlin.Function1)",
    "body": ".setRegion(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "MatchTemplatesConfig.setRegion\n设置区域构建器\n\n@param region 用于构建匹配区域的lambda表达式，通过Rect的扩展函数定义匹配区域；     null表示在整个图像范围内查找",
    "scope": "ruby"
  },
  "M8TestMatchTemplatesConfig.M8TestMatchTemplatesConfig.setOutputPath(kotlin.String)": {
    "prefix": ".M8TestMatchTemplatesConfig.setOutputPath(kotlin.String)",
    "body": ".setOutputPath(${1:outputPath}$0)",
    "description": "MatchTemplatesConfig.setOutputPath\n设置匹配结果图像输出路径\n\n@param outputPath 结果图像保存路径；null表示不保存结果图像",
    "scope": "ruby"
  },
  "M8TestMatchTemplatesConfig.M8TestMatchTemplatesConfig.setMethod(kotlin.Int)": {
    "prefix": ".M8TestMatchTemplatesConfig.setMethod(kotlin.Int)",
    "body": ".setMethod(${1:method}$0)",
    "description": "MatchTemplatesConfig.setMethod\n设置模板匹配方法\n\n@param method 匹配算法方法标识；null表示使用默认匹配方法",
    "scope": "ruby"
  },
  "M8TestMatchTemplatesConfig.M8TestMatchTemplatesConfig.setParallel(kotlin.Boolean)": {
    "prefix": ".M8TestMatchTemplatesConfig.setParallel(kotlin.Boolean)",
    "body": ".setParallel(${1:parallel}$0)",
    "description": "MatchTemplatesConfig.setParallel\n设置是否启用并行处理\n\n@param parallel true表示启用并行处理，false表示禁用；null表示使用默认设置",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getVariables(com.m8test.script.core.api.engine.ScriptContext)": {
    "prefix": ".M8TestOpencvComponent.getVariables(com.m8test.script.core.api.engine.ScriptContext)",
    "body": ".getVariables(${1:scriptContext}$0)",
    "description": "OpencvComponent.getVariables\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.addClassLoader(dalvik.system.BaseDexClassLoader)": {
    "prefix": ".M8TestOpencvComponent.addClassLoader(dalvik.system.BaseDexClassLoader)",
    "body": ".addClassLoader(${1:classLoader}$0)",
    "description": "OpencvComponent.addClassLoader\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.addClassLoader(kotlin.Function1)": {
    "prefix": ".M8TestOpencvComponent.addClassLoader(kotlin.Function1)",
    "body": ".addClassLoader(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "OpencvComponent.addClassLoader\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.addDependency(kotlin.Function1)": {
    "prefix": ".M8TestOpencvComponent.addDependency(kotlin.Function1)",
    "body": ".addDependency(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "OpencvComponent.addDependency\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.configureClassLoader(kotlin.Function1)": {
    "prefix": ".M8TestOpencvComponent.configureClassLoader(kotlin.Function1)",
    "body": ".configureClassLoader(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "OpencvComponent.configureClassLoader\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.configureClassLoader(dalvik.system.BaseDexClassLoader, kotlin.Function1)": {
    "prefix": ".M8TestOpencvComponent.configureClassLoader(dalvik.system.BaseDexClassLoader, kotlin.Function1)",
    "body": ".configureClassLoader(${1:dexClassLoader}, ${4:lambda {|${2:v1}|-\u003e \n    $3\n\\}}$0)",
    "description": "OpencvComponent.configureClassLoader\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.createClassLoader(kotlin.Function1)": {
    "prefix": ".M8TestOpencvComponent.createClassLoader(kotlin.Function1)",
    "body": ".createClassLoader(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "OpencvComponent.createClassLoader\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getApplication()": {
    "prefix": ".M8TestOpencvComponent.getApplication()",
    "body": ".getApplication($0)",
    "description": "OpencvComponent.getApplication\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getClassLoader()": {
    "prefix": ".M8TestOpencvComponent.getClassLoader()",
    "body": ".getClassLoader($0)",
    "description": "OpencvComponent.getClassLoader\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getClassLoaders()": {
    "prefix": ".M8TestOpencvComponent.getClassLoaders()",
    "body": ".getClassLoaders($0)",
    "description": "OpencvComponent.getClassLoaders\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getFilesDir()": {
    "prefix": ".M8TestOpencvComponent.getFilesDir()",
    "body": ".getFilesDir($0)",
    "description": "OpencvComponent.getFilesDir\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getName()": {
    "prefix": ".M8TestOpencvComponent.getName()",
    "body": ".getName($0)",
    "description": "OpencvComponent.getName\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getPackageInfo()": {
    "prefix": ".M8TestOpencvComponent.getPackageInfo()",
    "body": ".getPackageInfo($0)",
    "description": "OpencvComponent.getPackageInfo\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getPluginInfo()": {
    "prefix": ".M8TestOpencvComponent.getPluginInfo()",
    "body": ".getPluginInfo($0)",
    "description": "OpencvComponent.getPluginInfo\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getResources()": {
    "prefix": ".M8TestOpencvComponent.getResources()",
    "body": ".getResources($0)",
    "description": "OpencvComponent.getResources\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.getSettings()": {
    "prefix": ".M8TestOpencvComponent.getSettings()",
    "body": ".getSettings($0)",
    "description": "OpencvComponent.getSettings\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.loadClass(kotlin.String)": {
    "prefix": ".M8TestOpencvComponent.loadClass(kotlin.String)",
    "body": ".loadClass(${1:className}$0)",
    "description": "OpencvComponent.loadClass\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.registerUICreator(com.m8test.script.core.api.ui.UICreator)": {
    "prefix": ".M8TestOpencvComponent.registerUICreator(com.m8test.script.core.api.ui.UICreator)",
    "body": ".registerUICreator(${1:uiCreator}$0)",
    "description": "OpencvComponent.registerUICreator\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.removeClassLoader(dalvik.system.BaseDexClassLoader)": {
    "prefix": ".M8TestOpencvComponent.removeClassLoader(dalvik.system.BaseDexClassLoader)",
    "body": ".removeClassLoader(${1:classLoader}$0)",
    "description": "OpencvComponent.removeClassLoader\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.removeDependency(kotlin.Function1)": {
    "prefix": ".M8TestOpencvComponent.removeDependency(kotlin.Function1)",
    "body": ".removeDependency(${3:lambda {|${1:v1}|-\u003e \n    $2\n\\}}$0)",
    "description": "OpencvComponent.removeDependency\n",
    "scope": "ruby"
  },
  "M8TestOpencvComponent.M8TestOpencvComponent.unregisterUICreator(com.m8test.script.core.api.ui.UICreator)": {
    "prefix": ".M8TestOpencvComponent.unregisterUICreator(com.m8test.script.core.api.ui.UICreator)",
    "body": ".unregisterUICreator(${1:uiCreator}$0)",
    "description": "OpencvComponent.unregisterUICreator\n",
    "scope": "ruby"
  }
}